- 가상 함수
virtual 예약어를 앞에 붙여 선언한 메소드
가상 함수를 파생 형식에서 재정의하면 기본 클래스의 정의가 완전히 무시됨

class CMyString
{
public:
    virtual void OnSetString() {}; // virtual 메소드 내부는 비어있음
    SetString(const char*) // 일반 메소드
    {
        ...
        OnSetString(); // 미래를 호출
    }
};

CMyString 클래스에 대해 미래에 파생 클래스가 나오게 된다면 파생 클래스 내에서 OnSetString() 함수를 재정의 할 때 virtual이라는 말을 쓰지 않아도 자동으로 그 함수는 가상 함수

main() 내에서 CMyStringEx a; 를 선언하고 a.SetString() 을 하게 되면 기본 클래스 CMyString의 SetString()이 호출됨
이 때 SetString() 내의 가상 함수 OnSetString()을 호출하는 부분에서 가상 함수는 실 형식을 따르므로 a의 실 형식인 CMyStringEx 클래스에서 재정의된 OnSetString() 함수를 호출함

즉 OnSetString() 함수가 만들어진 것은 과거이나 파생 클래스에서 그 함수를 재정의하는 순간 미래를 호출하는 것이 됨

가상 함수는 언제? 왜? 호출되는가? - 과거의 기본 클래스가 미리 결정

미래의 파생 클래스에서 OnSetString() 함수에 대한 재정의는 어떤 식으로 이루어지는가?
OnSetString()
{
    1. 새로 추가된 코드
    2. CMyString::OnSetString() 과거 기본 클래스에 정의되어있는 코드
}
보통 1-2, 2-1, 1-2-1 순서로 코드가 쓰이는 경우가 많으나 2 없이 1만 써서 아예 오버라이딩 하는 경우도 있음

Framework를 사용할 때 고민해야할 부분 -> 내 코드를 '어디'에 끼워넣을 것인가? 어떤 클래스가 어떤 가상 함수를 가졌고 언제 호출되는지 정확하게 알아야 함

final
특정 가상 함수가 미래에 재정의되는 것을 막는 예약어
파생 클래스에서 가상 함수를 재정의하는 순간 컴파일 오류 발생

- 소멸자 가상화
상위 클래스 형식으로 하위 클래스가 참조할 때 상위 클래스 형식을 '추상 자료형'이라고 함
ex)
CMyData *pData = new CMyDataEx;
그렇다면 delete pData; 에서 호출되는 소멸자는 어느 것인가?
참조 형식 CMyData의 소멸자가 불림
-> 실 형식 CMyDataEx의 소멸자가 호출되지 않아 동적 할당된 메모리의 누수가 발생함

따라서 추상 형식으로 자료를 생성한 다음 추상 형식으로 자료를 삭제할 계획이라면 기본 클래스의 소멸자를 반드시 virtual 로 선언해야함

추상 자료형은 언제/왜 사용하는가?
소프트웨어의 내부에서 일어나는 과정
수집(입력) -> 처리 -> 결과

수집(사용자 입력) 시간은 소프트웨어의 입장에서 비교적 여유롭고 널널한 시간
처리와 같은 빠른 연산이 필요한 순간에 switch-case 문이나 다중 if 문과 같은 분류 행위를 하는 것은 비효율적
따라서 비교적 여유로운 사용자 입력 순간에 분류 등의 행위를 미리 해둠으로써 성능을 향상시킬 수 있음

But 경우의 수가 많이 늘어난다면 이와 같은 처리가 어려울 수 있으므로 lookup 배열이나 추상 자료형을 이용한 방법으로 변경해야함 