Selection sort
(1) 가장 큰 값을 찾음
(2) 가장 큰 값을 맨 끝자리의 데이터와 교환
(3) 맨 마지막 데이터(가장 큰 값)을 제외한 나머지 값들 중 가장 큰 값을 끝자리 값과 교환
(4) 남은 데이터가 한 개가 될 때까지 위를 반복

selectionSort(A[], n)
{
    for last <- n down to 2
    {
        A[1...last] 중 가장 큰 수 A[k]를 찾음;
        A[k] <-> A[last]; // A[k]와 A[last]의 값을 교환
    }
}
/* 수행시간
- for 루프는 n-1번 반복
- 가장 큰 수를 찾기 위한 비교횟수 : n-1, n-2, n-3...,2,1
- 값의 교환은 상수시간 작업
시간복잡도 T(n) = (n-1)+(n-2)+(n-2)+...+2+1 = O(n^2)
모든 데이터에 대해서 비교횟수가 동일하므로 최악, 최선, 평균 시간복잡도는 동일
*/

Bubble sort
- Selection sort와 거의 유사하나 최댓값을 찾아서 맨 마지막으로 가져오는 세부적인 방법에 차이가 있음
(1) 첫번째 값부터 시작하여 그 값의 다음번째 값과 자신을 비교하여 자신이 더 크면 둘의 자리를 바꿈
(2) 첫번째, 두번째, ... ,마지막-1 값까지 자신의 다음번째 값과 비교한 뒤 결과에 따라 자리 교환
(3) 마지막까지 도달하면 다시 첫번째 값부터 시작하여 마지막-2 값까지 다음번째 값과 비교 및 교환
(4) 남은 데이터가 한 개가 될 때까지 위를 반복

bubbleSort(A[], n)
{
    for last <- n down to 2
    {
        for i <- 1 to last-1
            if (A[i]>A[i+1]) then A[i] <-> A[i+1];
    }
}
/* 수행시간
- 첫번째 for 루프는 n-1번 반복
- 두번째 for 루프는 각각 n-1, n-2, ..., 2,1번 반복
- 값의 교환은 상수시간 작업
시간복잡도 T(n) = (n-1)+(n-2)+(n-2)+...+2+1 = O(n^2)
최악, 최선, 평균 동일
*/

삽입정렬 (Insertion sort)
- k-1개의 데이터가 정렬되어 있을때 k번째 데이터를 알맞은 자리에 끼워넣어서 결과적으로 k개의 데이터가 정렬된 상태가 되도록 만듦
- k번째 데이터의 자리를 찾기 위해 앞에서부터 비교를 하게 되면 알맞은 자리를 찾더라도 데이터의 삽입을 위해 그 자리 뒤의 데이터들을 모두 한 칸씩 뒤로 옮겨야하므로 결과적으로 모든 데이터를 한 번씩은 봐야 함
- 뒤에서부터 비교를 하게 되면 삽입되어야 할 자리를 찾지 못한 상태라도 어쨌든 비교 당한 데이터를 한 칸씩 뒤로 옮기고, 알맞은 자리를 찾은 후에는 앞의 남은 데이터에 대해서는 신경쓰지 않아도 됨
- 즉 앞에서부터 비교하기보단 뒤에서부터 비교하는 것이 더 효율적

insertionsort(A[], n)
{
    for i <- 2 to n
    {
        A[1...i]의 적당한 자리에 A[i] 삽입
    }
}
/* 수행시간
- for 루프는 n-1번 반복
- 삽입은 최악의 경우 i-1번 비교
최악의 경우 T(n) = (n-1)+(n-2)+(n-2)+...+2+1 = O(n^2)
*/