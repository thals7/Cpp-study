Hash Table
- dynamic set(탐색, 삽입, 삭제를 지원하는 자료구조)을 구현하는 효과적인 방법의 하나
  - 적절한 가정하에서 평균 탐색, 삽입, 삭제시간 O(1)
  - 보통 최악의 경우 Θ(n)
- 해쉬 함수(hash function) h를 사용하여 키 k를 T[h[k]]에 저장
  - h: U -> {0,1,...,m-1}
    - 여기서 m은 테이블의 크기, U는 모든 가능한 키들의 집합
  - 키 k가 h(k)로 해싱되었다고 말함
  - index = h(k) 즉, 각 키에 대한 해쉬함수값을 그 키에 저장할 배열 인덱스로 사용

해쉬 함수의 예
- 모든 키들을 자연수라고 가정 (어떤 데이터든지 자연수로 해석하는 것이 가능)
- 예: 문자열
  - ASCII 코드: C=67, L=76, R=82, S=83
  - 문자열 CLRS는
    (67·128³)+(76·128²)+(82·128¹)+(83·128º)=141,764,947
- 해쉬 함수의 간단한 예:
  - h(k) = k % m (즉, key를 하나의 자연수로 해석한 후 테이블의 크기 m으로 나눈 나머지)
  - 항상 0 ~ m-1 사이의 정수가 됨

충돌 Collision
- 두 개 이상의 키가 동일한 위치로 해싱되는 경우
- 즉, 서로 다른 두 키 k1과 k2에 대해서 h(k1)=h(k2)인 상황
- 일반적으로 |U|>>m 이므로 항상 발생 가능 (즉, 단사함수가 아님)
- 만약 |K|>m이라면 당연히 발생 (여기서 K는 실제로 저장된 키들의 집합)
- 충돌이 발생할 경우 대처 방법이 필요
- 대표적인 두 가지 충돌 해결 방법:
  - Chaining
  - Open addressing

Chaining
- 테이블의 각각의 칸에 어떤 키를 저장하지 않고 동일한 장소로 해싱된 모든 키들을 하나의 연결리스트로 저장

- 키의 삽입 (Insertion)
  - 키 k를 리스트 T[h[k]]의 맨 앞에 삽입: 시간복잡도 O(1)
  - 중복된 키가 들어올 수 있고 중복 저장이 허용되지 않는다면 삽입시 리스트를 검색해야함. 따라서 시간복잡도는 리스트의 길이에 비례
- 키의 검색 (Search)
  - 리스트 T[h[k]]에서 순차검색
  - 시간복잡도는 키가 저장된 리스트의 길이에 비례
- 키의 삭제 (Deletion)
  - 리스트 T[h[k]]로부터 키를 검색 후 삭제
  - 일단 키를 검색해서 찾은 후에는 O(1)시간에 삭제 가능

- 최악의 경우는 모든 키가 하나의 슬롯으로 해싱되는 경우
  - 길이가 n인 하나의 연결리스트가 만들어짐
  - 따라서 최악의 경우 탐색시간은 Θ(n)+해쉬함수 계산시간
- 평균시간복잡도는 키들이 여러 슬롯에 얼마나 잘 분배되느냐에 의해서 결정

SUHA (Simple Uniform Hashing Assumption)
- 각각의 키가 모든 슬롯들에 균등한 확률로 (equally likelty) 독립적으로 (independently) 해싱되다는 가정
  - 성능분석을 위해서 주로 하는 가정
  - hash함수는 deterministic하므로 현실에서는 불가능 (특정 키 값의 해시함수값은 정해져있음)
- Load factor α = n/m
  - n: 테이블에 저장될 키의 개수.
  - m: 해쉬테이블의 크기, 즉 연결리스트의 개수
  - 각 슬롯에 저장된 키의 평균 개수
- 연결리스트 T[j]의 길이를 nj라고 하면 E[nj] = α
- 만약 n=O(m)이면 평균검색시간은 O(1)

Open addressing
- 모든 키를 해쉬 테이블 자체에 저장
- 테이블의 각 칸(slot)에는 1개의 키만 저장
- 충돌 해결 기법
  - Linear probing
  - Quadratic probing
  - Double hashing

- Linear Probing
  - h(k), h(k)+1, h(k)+2,… 순서로 검사하여 처음으로 빈 슬롯에 저장
  - 테이블의 끝에 도달하면 다시 처음으로 circular하게 돌아감
  - search의 경우 해쉬함수값부터 그 다음 슬롯들을 연속해서 비교해가며 동일한 키를 찾거나 빈 슬롯이 나오면 종료
  - 단점
    - primary cluster: 키에 의해서 채워진 연속된 슬롯
    - 이런 cluster가 생성되면 이 cluster는 점점 더 커지는 경향이 생김
    - search의 시간이 클러스터의 길이에 비레하게 되므로 큰 cluster가 생기는 것은 좋지 않음

- Quadratic probing
  - 충돌 발생시 h(k), h(k) + 1^2, h(k) + 2^2, h(k) + 3^2,... 순서로 시도

- Double hashing
  - 서로 다른 두 해쉬 함수 h1과 h2를 이용하여
  - h(k,i) = (h1(k) + i·h2(k)) mod m // i=0부터 시작해서 충돌이 생길 경우 i=1,i=2,...

- 키의 삭제 (Deletion)
  - 단순히 키를 삭제할 경우 문제가 발생
    - 가령 A2, B2, C2가 순서대로 모두 동일한 해쉬함수값을 가져서 linear probing으로 충돌을 해결했을 경우
    - B2를 삭제하게 되면 이후 C2를 검색할 때 문제 발생 (A2와 C2사이에 B2가 삭제된 빈슬롯이 생겨버림)
    - 따라서 어떤 키를 삭제하고 난 뒤 그 다음 연속한 키들의 원래 해쉬함수값이 삭제한 키의 해쉬함수값보다 작거나 같다면 그것을 삭제된 키의 자리로 옮겨오는 작업이 필요함

좋은 해쉬 함수란?
- 현실에서는 키들이 랜덤하지 않음
- 만약 키들의 통계적 분포에 대해 알고 있다면 이를 이용해서 해쉬 함수를 고안하는 것이 가능하겠지만 현실적으로 어려움
- 키들이 어떤 특정한 (가시적인) 패턴을 가지더라도 해쉬함수값이 불규칙적이 되도록 하는게 바람직
  - 해쉬함수값이 키의 특정 부분에 의해서만 결정되어선 안됨

해쉬 함수
- Division 기법
  - h(k) = k mod m
  - ex) m = 20 and k = 91 ⇒ h(k) = 11
  - 장점: 한번의 mod연산으로 계산하므로 속도가 빠름
  - 단점: 어떤 m값에 대해서는 해쉬 함수값이 키값의 특정 부분에 의해서 결정되는 경우가 존재. 가령 m=2^P 이면 키의 하위 p비트가 해쉬 함수값이 됨
- Multiplication 기법
  - 0에서 1사이의 상수 A를 선택: 0<A<1
  - kA의 소수부분만을 택함
  - 소수 부분에 m을 곱한 후 소수점 아래를 버림
  - ex) m=8, word size = w = 5, k = 21
    - A = 13/32를 선택
    - kA = 21⋅13/32 = 273/32 = 8 + 17/32
    - m (kA mod 1) = 8 · 17/32 = 17/4 = 4.~
    - 즉, h(21) = 4