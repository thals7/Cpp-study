- 정렬
최댓값과 최솟값을 계속해서 구해나가다 보면 (선택)정렬이 됨
선택 정렬 :  왼쪽부터 정렬이 끝남
버블 정렬 : 오른쪽부터 정렬이 끝나며 비교 조건을 만족하는 경우 매번 변수를 교환함
Quick sort : 평균 정렬 속도 가장 빠름

알고리즘에서는 교환 횟수 고려하지 않음 비교 횟수가 중요

- Lookup 배열
정보검색 기능을 제공할 목적으로 사용된 배열
선택의 개념을 구현하는 데 사용 가능
ex)
int main(int argc, char* argv[])
{
    //전체 경우에 대한 과금률 결과를 담은 배열의 선언 및 정의
    double aRate[10] = {
        0.0, 0.1, 0.25, //1~3세
        0.5, 0.5,       //4~5세
        0.6, 0.65,      //6~7세
        0.8, 0.82, 0.97 //8~10세
    };
    int nAge = 0, i = 0, nFee = 1000;

    //요금표를 출력
    printf("요금표\n");
    for (i = 1; i <= 10; ++i)
        printf("%d세 요금 :\t%d원\n", i, (int)(nFee*aRate[i-1]));
    putchar('\n');
    
    //나이를 입력받고 배열 인덱스 범위 내부로 값을 강제 조정
    printf("나이를 입력하세요. : ");
    scanf("%d", &nAge);
    if (nAge < 1)   nAge = 1;
    else if (nAge > 10) nAge = 10;
    
    //나이에 맞는 배열요소를 선택하고 별다른 제어문 없이 즉시 값을 출력
    printf("최종요금 : %d원\n", (int)(nFee*aRate[nAge-1]));
    putchar('\n');
    return 0;
}

경우가 증가할 경우 배열의 크기 또한 증가함
그 중 index에 해당하는 것을 계산으로 선택할 수만 있다면 일정한 부하(CPU를 쓰는) 기준으로 어떤 경우 하나를 즉시 선택할 수 있음
즉 Lookup 배열을 이용하면 if else문이나 다중 if문 또는 switch-case문에 비해 선택하는 속도가 일정해짐 (성능 향상)