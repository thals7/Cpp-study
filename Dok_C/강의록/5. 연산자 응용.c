- sizeof
cpu를 사용하는 연산이 아니기 때문에 아무리 사용해도 부하가 올라가지 않음
가급적 자주 사용하는게 좋음

sizeof() -> 괄호 안에 들어가는 피연산자가 되는 것은 자료형
ex) sizeof(1) = int형의 크기 4
    sizeof('1') = char형의 크기 1
    sizeof(int형 변수 + 1.2) = type promotion으로 double형의 크기 8

이 모든 연산은 Compiler가 실행 (컴파일 타임 연산)
sizeof(aList) vs int[5]의 사이즈 20 직접 입력
둘 다 값은 20으로 같으나 전자로 쓰는 것이 좋음
why? wchar_t 같은 자료형의 경우 유니코드 형식에 따라 용량이 달라짐
     즉 sizeof 를 썼을때의 결과가 환경마다 달라질 수 있음
     따라서 배열의 크기를 직접적으로 선언하는 것은 '유지보수'하기 좋은 코드가 아님

- 컴퓨터의 연산
int a, b; 에서 a - b; a == b; 의 값을 알기 위해 수행되는 연산은 동일함
a와 b가 같은지 확인하기 위해 a - b를 하고, 그 값이 0이면 a == b임을 알 수 있음

int a,b;
a - b; 를 %d로 출력하면? a - b의 계산값(ex.3)
a > b; 를 %d로 출력하면? 1(True) or 0(False)

- 실수의 연산
실수는 절대로 상등 or 부등 연산을 해서는 안됨 -> 부동소수점 오차
ex) printf("%d\n", 2147483600.0F == 2147483648.0F); 을 실행하면?
    결과값이 1(True)이 나옴
따라서 상등, 부등 연산이 필요할 경우 비교 연산으로 >=나 <=를 사용하는 것이 좋음

*switch-case문을 사용할 때
case 정수: 로 해야함 (실수X) -> 내부적으로 상등 연산을 수행하기 때문

-논리 연산자
&& (and)
|| (or)
! (not) : 단항 연산자

*short-circuit evaluation
A && B || C
이라는 식이 있을 때 A가 참이면 B를 계산하지 않고 바로 C로 넘어감
즉 관계 연산을 한 번 건너뜀으로써 성능이 향상될 수 있음

조건식의 경우 판단하는데 걸리는 '시간'을 생각해야함
연산은 항상 왼쪽에서 오른쪽으로 이루어지므로 왼쪽에
1. 쉬운(빠른) 연산
2. 자주 적중할 조건
의 식을 배치하는 것이 좋음

- 코드는 '문서'다
나 혼자 보는 일기가 아님
나와 타인 모두 알아보기 쉽게 작성해야 함
많은 사람과 나누는 것도 중요

- 삼항 연산자
조건 ? 항1 : 항2
조건이 참인 경우 항1, 거짓인 경우 항2가 선택됨
if, else로 분기하는 부분을 한 줄로 간단하게 표현 가능
ex) int num1 = 5;
    int num2;
    num2 = num 1? 100: 200;
    printf("%d\n", num2);

    함수 안에서도 사용 가능
    printf("%s\n", num1 == 10? "10입니다." : "10이 아닙니다.");
    이 때는 num2를 정의하지 않아도 됨
 
- 최댓값 구하기
최댓값을 구하기 위한 가장 좋은 알고리즘은 무엇인가?
1. 비교 횟수
2. 유지보수 및 확장성 : 매우 중요
3. 메모리 사용량 : 고성능도 중요하지만 범용적인 PC의 경우 전산자원(CPU,RAM)을 최대한 덜 쓰는 것이 좋음
이 세가지를 고려한 알고리즘을 짜야함

정렬 : 최댓값/최솟값을 여러번 찾음
최대/최소를 구하는 것은 기본이자 필수적인 능력