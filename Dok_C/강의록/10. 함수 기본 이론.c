- 함수
무엇을/왜 함수로 만들 것인가?

int main()
{
    ...
    puts(..);
}
와 같은 코드가 있을 때
main() : Caller(호출자)
puts() : Callee(피호출자)

ex)
int Add(int a, int b)   //함수 시그니처, 함수 원형
{   
    int nResult;
    nResult = a + b;
    return nResult;
}

int main()
{
    int nResult = 0;
    nResult = Add(3, 4);
    printf("%d\n", nResult);
    return 0;
}
-----
int : 반환 형식
Add : 함수 이름
int a, int b : 매개변수
int nResult : 지역변수 (자신이 속한 {} 안에서만 유효 / Add 함수 안의 nResult와 main 함수 안의 nResult는 다른 것임)

int a 와 int b는 형식인수임
따라서 함수를 사용할 땐 형식인수를 실인수로 명기해야함
실인수로 명시하는 쪽은? Caller(main)

nResult = Add(3,4);에서 괄호()를 함수 호출 연산자라고 부름
이 때 Add는 피연산자가 됨
피연산자는 반드시 함수 형식을 가져야 함
함수 형식이란? 반환형식 이름(매개변수) (ex.int Add(int a, int b))

- 함수 설계 원칙
1. UI와 기능의 분리
사용자 인터페이스(겉으로 드러나는 외형)와 내부기능은 반드시 분리할 것

예를 들어 나이를 입력하면 요금을 계산해주는 프로그램을 만들 경우 나이를 입력받는 함수(UI)와 계산을 통해 요금을 알아내는 함수를 분리하여 구현하는 것이 좋음

매개변수 유효성 검사 : 함수의 제작자인 Callee가 해야함
Caller는 Callee가 제작한 함수를 사용(호출)할 뿐임

함수의 개수가 많아지는 것 걱정 X
나눌 수 있으면 조각내는 것이 좋음

이벤트 루프 : 메뉴를 출력하고 사용자가 원하는 메뉴 선택을 입력받아 메뉴에 대응하는 기능을 수행하는 함수를 만든 뒤, 이 함수를 main() 함수에서 반복해서 호출함
그리고 반환받은 사용자의 선택을 switch-case문으로 분석해 메뉴에 대한 적절한 문자열을 출력

2. 재사용 가능한 단위 기능의 구현
하나의 단위기능(평균 계산, 최댓값 찾기, 정렬 등)으로 규정할 수 있는 대상은 함수로 만들 것

DRY(Don`t repeat yourself) 원칙 :
같은 일을 수행하는 코드가 중복(여러 곳에 존재)되지 않도록 함

3. 코드 분할
덩치가 너무 큰 코드는 변화에 대응하기 어려움 (유지보수 힘듦)
스스로 생각했을 때 너무 큰 코드라고 판단되면 일정 수준으로 크기를 줄여 여러 함수로 코드를 나누는 것이 좋음

* 함수의 이름에서 기능이 무엇인지 직관적으로 알 수 있게
* 분할된 코드가 들어있는 피호출자 함수에 반드시 전달되어야 할 정보는 무엇인지 확정(매개변수)
* 호출자 함수는 피호출 함수를 호출하는 것으로 끝나는 것인지 아니면 반드시 어떤 정보를 반환받아야 하는지 확정(반환 자료형)

- 함수의 원형 선언
변수와 함수는 문법적으로 선언과 정의가 분리될 수 있음
함수 정의보다 함수를 호출하는 코드가 더 먼저 등장하는 경우 함수의 원형(prototype) 선언을 소스코드 상단에 기술함으로써 컴파일러에 함수의 존재를 알려야 함

ex)
#include <stdio.h>

int Add(int, int); //함수 원형 선언

int main()
{
    printf("%d\n", Add(3,4)); //아직 함수 정의가 나오지 않았지만 Add() 함수가 존재한다는 사실을 컴파일러가 알고 있으므로 컴파일 오류 발생 X
}

int Add(int x, int y) // 함수 정의
{
    return x+y;
}

함수 원형 선언들이 한데 뭉쳐진 파일을 헤더 파일(~~.h)이라고 함
함수 정의가 들어가있는 파일은 ~~.c