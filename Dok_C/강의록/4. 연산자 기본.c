- C언어
코드의 덩어리를 Blockscope{}를 이용해 표현한 것
{}안에 들어있는 것이 구문 -> 보통 세미콜론;으로 끝남
구문은 항(statement)으로 이루어짐

여러 항들이 모여 구문을 이루고, 구문이 모여 scope를 이뤄서 코드 덩어리를 이루고, 그 덩어리 n개가 모여서 하나의 함수가 됨
그 함수들이 호출, 피호출의 관계로 연결(bind)되면서 하나의 프로그램을 이루게 됨

- 연산의 임시결과
3+4+5 라는 연산에서 우선 3과 4를 더해 7이라는 임시결과를 내고 여기에 5를 더함
12라는 최종 결과가 나온 뒤에는 7이라는 임시결과가 필요없으므로 삭제됨
이 때 나중에 임시결과가 필요하다면 7을 어딘가에 저장해두어야 함
이를 저장하기 위해 필요한 것이 변수 -> 즉 임시결과는 변수에 저장 가능

- '=' 단순 대입
Copy & Overwrite

int a;
a = 10;
여기서 a는 변수(l-value) 10은 상수(r-value)
이 때 l-value의 l은 단순히 left가 아닌 lcoation(위치지정자)
r-value는 l-value가 될 수 없음 (ex. 10 = 12; error)

const int a = 10;
변수 앞에 const가 붙으면 상수가 됨 (l-value가 상수화된 개체가 됨)
따라서 const 선언 후 a의 값을 바꾸는 것은 불가능

- 이형자료간의 연산
'A'(char) + 1(int) = ?
표현 범위가 큰 형식이 이김
즉 char(1bytes) < int(4bytes) 이므로 int 형식이 됨

123.45(double) + 1(int) = ?
double(8bytes) > int(4bytes) 이므로 double 형식이 됨

* But! 'A'(65) + 1 = 'B'(66)
  그렇다면 'B' = int?
  -> putchar()의 매개변수 자료형식이 int인 이유
  putchar('A'+1);을 했을 때 화면에는 B가 출력되지만 자료형은 int 형식이 됨
  이러한 type promotion(연산의 결과가 피연산자의 자료형보다 표현범위가 넓은 형식으로 변경되는 현상) 문제 때문에 putchar()의 매개변수 자료형식은 char가 아닌 int가 됨

- 나누기의 문제
5(int)/2(int) = 2.5(double) ?
따라서 int/int = int 를 맞춰주기 위해 2.5에서 소수점 이하 .5는 절사됨
즉 C에서 5(int)/2(int) = 2(int)

But! 5(int)/2.0(double) = 2.5(double) (∵int<double)
따라서 pritf에서 형식문자로 %lf 또는 %f로 출력하면 됨

- % (나머지 연산자)
/ 이나 % 이나 나누기 연산이 일어나는 것은 같음
단지 결과값으로 몫을 취하냐, 나머지를 취하냐의 문제

- 컴퓨터의 나눗셈 방식
ex) 7/2
    7-2=5
    5-2=3
    3-2=1
    총 3번의 뺄셈을 수행했으므로 몫은 3, 남은 1은 나머지가 됨

    7/0
    7-0 을 무한으로 수행?
    interrupt가 발생해서 바로 프로그램을 중단시킴

- 두 변수의 값 바꾸기
int a = 5;
int b = 10;
일때 a와 b의 값을 서로 바꾸기 위해
a = b;를 하게 되면 원래 a였던 값 5는 사라지게 됨

따라서 a 값을 미리 저장해두고 b값을 a에 대입한 뒤 b에는 미리 저장해둔 a의 값을 불러와야 함
그러기 위해 필요한 제 3의 변수를 보통 temp라고 지음
int a = 5;
int b = 10;
int temp;
temp = a;
a = b;
b = temp;
이렇게 하면 a는 10, b는 5가 됨

- 비트 연산자
^ (XOR연산) : 두 개의 비트가 다르면 1을 반환
ex) a = 4; // 0000 0100
    b = 8; // 0000 1000
    c = a ^ b; // 0000 1100 = 12

~ (NOT연산) : 한 값의 비트를 모두 반전시킴 (피연산자 1개)
ex) a = 4; // 0000 0100
    b = 8; // 0000 1000
    c = ~a // 1111 1011 = 251
    d = ~b // 1111 0111 = 247

<< (왼쪽 shift) : 지정한 횟수대로 비트의 자리를 왼쪽으로 이동시킴
ex) a = 6 << 3; // 0000 0110 -> 0011 0000 = 48
    b =  << 2; // 0000 1000 -> 0010 0000 = 32
이 때, 변수가 char형이면 8-bit기 때문에 8자리를 이동하게 되면 1이 잘려서 사라지고 0이 됨
그러나 int형은 32-bit기 때문에 8자리를 이동할 수 있고 정상적으로 256이 됨

>> (오른쪽 shift) : 지정한 횟수대로 비트의 자리를 오른쪽으로 이동시킴
ex) a = 14 >> 3; // 0000 1110 -> 0000 0001 = 1
    b = -16 >> 2 // 0001 0000 -> 0000 0100 = -4