- 배열
형식이 같은 자료 여러 개가 모여 새로운 하나를 이룬 형식 : 집합체

int aList[5] -> int 가 5개인 배열
aList : 식별자(이름)
aList의 자료형은 무엇인가? int[5] (int가 5개 있는 배열)
즉 sizeof(int[5])와 sizeof(aList)는 같음

자료형 : 일정 길이의 메모리에 저장된 정보를 해석하는 방법
 
배열의 이름 != 변수의 이름
배열의 이름은 그 자체로 주소가 됨

배열의 가장 큰 특징 : 위치를 설명할 때 가장 왼쪽에 있는 것이 기준이 되어 그것으로부터 (오른쪽으로)얼마나 떨어져있는지(Index) 계산함
-> 즉 위치를 상대적으로 표현
기준주소 + 인덱스(정수) -> 상대주소
기준주소는 전체에 대한 것이지만 상대주소는 하나에 대한 것 

** aList == &aList == aList + 0 == &aList[0]
aList는 맨 왼쪽에 있는 셀 하나의 주소이면서 동시에 그 배열을 대표함

aList + index != &aList + index
&alist는 int[3] 자체를 뜻함 -> 여기에 + index를 한다는 것은 그 배열 전체에서 오른쪽으로 index만큼 간다는 것
즉 &List + 1 을 하게 되면 기준주소에서 12만큼(4byte*3) 뛴 주소가 나오게 됨

aList + 2 == &aList[2]

정렬을 하기 위해선 최대/최소를 구하는 방법을 알아야 함
그리고 최대/최소를 알기 위해서는 비교와 교환하는 방법을 알아야 함

- 문자열
"Hello" -> 상수화된 문자배열
자료형은? char[6] : char가 6개 있는(마지막 null문자 포함) 배열
배열 전체는 0번 요소의 주소로 식별
"Hello" 자체는 문자열 -> 이것의 첫글자가 저장된 메모리의 주소를 char에 대한 포인터에 담는 것(char*)

ex)
int main()
{
    //배열 각 요소의 값을 하나씩 기술하는 방식으로 초기화
    int aList = { 30, 40, 10, 50, 20 };
    char szBuffer[6] = { 'H', 'e', 'l', 'l', 'o', '\0' };

    //문자열 형태로 문자집합을 기술하는 방식으로 배열 초기화
    char szData[8] = { "Hello" };

    //문자열 상수를 가리키는 포인터 변수 선언 및 초기화
    char *pszBuffer = "Hello";

    //문자열은 모두 같은 방식으로 출력
    puts(szBuffer);
    puts(szData);
    puts(pszBuffer)
    return 0;
}

** 문자열은 '가변'길이

- 문자열의 끝이 null(\0)인 이유
char szBuffer[8];에 "Hello\0"를 저장한다면 뒤에 2칸이 남게됨
즉 \0을 기준으로 왼쪽은 문자열로 채워진 영역, 오른쪽은 남은 공간이 됨
따라서 \0이 나올때까지 세는 방법으로 문자열의 길이를 측정할 수 있음

- 다차원 배열
배열의 배열
char[4]인 배열이 나란히 3개가 있을때 char[3][4]로 표현
[3]은 행 [4]는 열이 됨 character는 12개
int aList[3][4] 와 int aList[12]의 메모리 구조는 완전히 같음
단지 접근방법만 다를 뿐임
논리적으로는 2차원이지만 모든 컴퓨터의 메모리는 1차원 구조로 되어있음