- 전처리기
컴파일러가 소스코드를 컴파일하기 전에 미리 선행 처리하는 구문
'#' 기호가 앞에 붙어있는 외형적 특징 지님

compile 전 처리
무엇을? 코드를 변형
cpu의 연산과는 상관이 없음 (오직 컴파일 타임에만 일어나는 연산)

- #include
외부 파일(보통은 헤더 파일)을 현재 소스 코드의 위쪽에 포함시켜서 함께 컴파일하도록 해줌

#include <~~~.h> : 컴파일러 설정의 시스템 디렉토리에서 헤더 파일을 검색
#include "~~~.h" : 프로젝트나 솔루션의 현재 경로에서 헤더 파일을 검색

- 매크로
외형상 함수의 모습을 하고 있으나, 실제로는 함수가 아니라 한 행 혹은 여러 행으로 기수할 수 있는 구문(혹은 항)

함수가 다른 함수를 호출하면 그 과정에서 비용(스택의 증가, 매개변수의 복사 등)이 발생하고 제어(흐름)에도 변화가 생김
따라서 코드 조각의 내용이 매우 적고 자주 호출된다면 함수가 아닌 매크로를 만드는 것이 유용함

but 매크로 사용은 자제하는 것이 좋음 -> 대신 __inline 함수를 사용
__inline 함수의 경우 사용자가 실제로 기입하는 경우는 많지 않음
컴파일러가 inline화 할 수 있는지 스스로 판단하고 결정해서 실행(함수임에도 매크로처럼 번역이 되어 함수 호출을 하지 않음)


- 매크로 특수화 연산자 # , ##

ex)
#define STRING(a)   #a
#define PASTER(a,b) a##b

int main()
{
    int nData = 10;

    printf("%d\n", PASTER(nDA, ta));
    printf("%d\n", nData);
    printf("%s\n", STRING(nData)); // 변수 이름이 STRING() 매크로에 의해 nData라는 문자열로 변경되어 문자열 상수로 처리됨(int형 변수 nData와 관련 X)
}
/*
실행 결과
10
10
nData
*/

- 조건부 컴파일
#if, #else, #endif
와 같은 전처리기를 사용해서 특정한 상황(상수 정의)에 따라 실제로 번역되는 소스코드가 달라지도록 구성하는 것

ex)
int main()
{
#ifdef _DEBUG
    puts("Debug mode");
#else
    puts("Release mode");
#endif
    return 0;
}
/*
빌드 모드가 디버그 모드이면
Debug mode 출력
릴리즈 모드이면
Release mode 가 출력됨
*/