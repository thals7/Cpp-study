좋은 알고리즘(프로그램)이란?
- 속도가 빠른 것
- 프로그램이 얼마나 잘 구조화되어있는가? 모듈화되어있는가?
- (GUI의 경우)미적으로 아름다운가?
등등

알고리즘의 분석
- 알고리즘의 자원(resource) 사용량을 분석 // 모든 경우에 적용할 수 있는 보편화된 한가지 기준
- 자원이란 실행 시간, 메모리, 저장장치, 통신 등
- 여기서는 실행시간의 분석에 대해서 다룸

시간복잡도 time complexity
- 실행시간은 실행환경에 따라 달라짐
  - 하드웨어, 운영체제, 언어, 컴파일러 등
- 실행시간을 측정하는 대신 연산의 실행 횟수를 카운트
- 연산의 실행 횟수는 입력 데이터의 크기에 관한 함수로 표현
- 데이터의 크기가 같더라도 실제 데이터에 따라서 달라짐
  - 최악의 경우 시간복잡도 (worst-case analysis)
  - 평균 시간복잡도 (average-case analysis)
  - 문제가 복잡해질 경우 평균 시간복잡도의 분석이 불가능하거나 매우 어려워지므로 대부분 최악의 경우 시간복잡도를 분석하게 됨

점근적(Asymptotic) 분석
- 점근적 표기법을 사용
  - 데이터의 개수 n->∞일때 수행시간이 증가하는 growth rate로 시간복잡도를 표현하는 기법
  - Θ-표기, O-표기 등을 사용
- 유일한 분석법도 아니고 가장 좋은 분석법도 아님
  - 다만 (상대적으로) 가장 간단하며
  - 알고리즘의 실행환경에 비의존적
  - 따라서 가장 광범위하게 사용됨


점근적 분석의 예
: 상수 시간복잡도
int sample(int data[], int n) // 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 중 n/2번째 데이터를 반환
{
    int k = n/2;
    return data[k];
}
n에 관계없이 상수 시간이 소요됨
이 경우 알고리즘의 시간복잡도는 O(1)

: 선형 시간복잡도
int sum(int data[], int n) // 입력으로 n개의 데이터가 저장된 배열 data가 주어지고, 그 합을 구하여 반환
{
    int sum = 0;
    for (int i=0; i<n; i++)
        sum += data[i]; // <- 이 알고리즘에서 가장 자주 실행되는 문장이며, 실행 횟수는 항상 n번. 가장 자주 실행되는 문장의 실행횟수가 n번이라면 모든 문장의 실행 횟수의 합은 n에 선형적으로 비례하며, 모든 연산들의 실행횟수의 합도 역시 n에 선형적으로 비례
    return sum;
}
선형 시간복잡도를 가진다고 말하고 O(n)이라고 표기

: 순차탐색
int search(int data[], int n, int target) // 배열 data에 정수 target이 있는지 검사
{
    for (int i=0; i<n; i++)
    {
        if (data[i] == target) // <- 이 알고리즘에서 가장 자주 실행되는 문장이며, 실행 횟수는 최악의 경우 n번
            return i;
    }
    return -1;
}
최악의 경우 시간복잡도는 O(n)

Quadratic
bool is_distinct(int n, int x[]) // 배열 x에 중복된 원소가 있는지 검사
{
    for (int i=0; i<n-1; i++;)
    {
        for (int j=i+1; j<n; j++)
        {
            if (x[i]==x[j]) // <- 이 알고리즘에서 가장 자주 실행되는 문장이며, 최악의 경우 실행 횟수는 n(n-1)/2번
                return false; // 중복이 있을때
        }
    }
    return true; // 중복이 없을때
}
최악의 경우 배열에 저장된 모든 원소 쌍을 비교하므로 비교 연산의 횟수는 n(n-1)/2. 최악의 경우 시간복잡도는 O(n^2)


점근적 표기법
- 알고리즘에 포함된 연산들의 실행 횟수를 표기하는 하나의 기법
- 최고차항의 차수만으로 표시
- 따라서 가장 자주 실행되는 연산 혹은 문장의 실행횟수를 고려하는 것으로 충분